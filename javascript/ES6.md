# ES6
### Number
+ `Number.isFinite()`和`Number.isNaN()`与传统的全局方法`isFinite()`和`isNaN()`的区别在于，传统方法先调用`Number()`将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，`Number.isFinite()`对于非数值一律返回`false`, `Number.isNaN()`只有对于NaN才返回`true`，非`NaN`一律返回`false`。
+ `Number.isInteger`判断是否为整数，不会进行隐式转换，因为在js内部整数和浮点数采用的是同样的储存方法，所以例如25和25.0视为同一个值都会返回true；另外js采用IEEE754标准，数值存储为64为双精度格式，数值精度最多可以达到 53 个二进制位（1 个隐藏位与 52 个有效位），如果数值的精度超过这个限度，第54位及后面的位就会被丢弃，这种情况下，可能会误判，例如：
  ```javascript
  Number.isInteger(3.0000000000000002) // true
  ```
这是因为这个小数的精度达到了小数点后16个十进制位，转成二进制位超过了53个二进制位，导致最后的那个2被丢弃了。
+ js内部中能表示最大的整数范围在`-2^53`到`2^53`之间，也就是`-9007199254740991`和`9007199254740991`之间，在js中用`Number.MAX_SAFE_INTEGER`和`Number.MIN_SAFE_INTEGER`表示，`Number.isSafeInteger`用于检测一个整数是否是安全的（在最大和最小之间）。另外，`9007199254740993 === 9007199254740992`会返回true，这时因为如果一个整数超出了最大整数，那么在计算机内部会以`9007199254740992`的形式储存，所以返回true
+ `BigInt`类型数值可以使用`-`号，不能使用`+`号，因为会与`asm.js`冲突
+ `BigInt`类型表示为在数值后面加上`n`，例如：`123n`；`BigInt('123n')`会报错，因为无法解析成Number，所以报错了；如果参数为小数，也会报错


